<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Superpixel Benchmark: Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Superpixel Benchmark
   </div>
   <div id="projectbrief">Superpixel benchmark, tools and algorithms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Command line tool for running an adapted W as example used in</p>
<p>The following will be a complete example of how to help us integrate a new superpixel algorithms into the benchmark. The following steps are discussed:</p>
<ul>
<li><a href="#dataset">Preparing the BSDS500 Dataset</a></li>
<li><a href="#implementation">Preparing the Implementation</a></li>
<li><a href="#parameter-optimization">Performing Parameter Optimization</a></li>
<li><a href="#evaluation">Performing Evaluation</a></li>
<li><a href="#submit-implementation">Submit Implementation and Results</a></li>
</ul>
<p>As example, we will use the watershed algorithm, W, as it is available through OpenCV. Note that this assumes that the algorithm is implemented in C/C++.</p>
<p>The source code of the example can be found in <code>examples/submission</code>.</p>
<p>Similar examples for other programming languages are:</p>
<ul>
<li><code>wp_cli</code> (Python)</li>
<li><code>pf_cli</code> (Java)</li>
<li><code>rw_cli</code> (MatLab)</li>
<li>...</li>
</ul>
<p><b>Prerequisites:</b></p>
<p>The examples assumes the benchmark to be installed in the home directory, e.g. through </p><pre class="fragment">$ git clone https://github.com/davidstutz/superpixel-benchmark --recursive
$ cd superpixel-benchmark
</pre><p>We assume the benchmark to be built, see <a class="el" href="BUILDING_8md.html">Building</a> for instructions. At least <code>lib_eval</code> needs to be built. Adapt <code>CMakeLists.txt</code> if it is not desired to built any other algorithms.</p>
<p>Datasets are assumed to be put into <code>~/superpixel-benchmark/data</code>; for the BSDS500 dataset approximately 1GB of space is required.</p>
<h2>Dataset</h2>
<p>As example, we will use the BSDS500 dataset which needs to be converted manually as it is currently not available in the <a href="https://github.com/davidstutz/superpixel-benchmark-data">data repository</a>.</p>
<p>To convert the BSDS500 dataset, we follow <code>lib_tools/bsds500_convert_script.m</code>:</p>
<ul>
<li>Download the dataset from <a href="https://www2.eecs.berkeley.edu/Research/Projects/CS/vision/grouping/resources.html">here</a>.</li>
<li>Extract the contents of <code>BSR/BSDS500/data</code> into <code>~/superpixel-benchmark/data/BSDS500</code> such that the subdirectories are <code>groundTruth</code> and <code>images</code>.</li>
<li>In <code>lib_tools/bsds500_convert_script.m</code> set <code>BSDS500_DIR</code> to the full (i.e. absolute) path to <code>~/superpixel-benchmark/data/BSDS500/</code> with trailing <code>/</code>.</li>
<li>Open MatLab, navigate to <code>~/superpixel-benchmark/lib_tools/</code> and run the script. This may take some time.</li>
</ul>
<p>After following the above instructions, <code>~/superpixel-benchmark/data/BSDS500/</code> will additionally contain <code>csv_groundTruth</code>.</p>
<h2>Implementation</h2>
<p>In our example, W is implemented as part of OpenCV. Thus, only an appropriate command line tool is required. In order to also demonstrate parameter optimization, an extra parameter is added by smoothing the image with a Gaussian kernel before running W. The following listing shows the command line tool <code>w_cli</code> reduced to the essentials: </p><pre class="fragment">#include &lt;fstream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;boost/filesystem.hpp&gt;
#include &lt;boost/program_options.hpp&gt;
#include &lt;boost/timer.hpp&gt;
#include &lt;bitset&gt;
#include "io_util.h"
#include "superpixel_tools.h"
#include "visualization.h"

/**     * docs/EXAMPLE.md to show how to submit a new algorithm to the benchmark.
 * Usage:
 * @code {sh}
 *   $ ../bin/example_command_line_tool --help
 * Allowed options:
 *   -h [ --help ]                   produce help message
 *   -i [ --input ] arg              the folder to process (can also be passed as 
 *                                   positional argument)
 *   -s [ --superpixels ] arg (=400) number of superpixles
 *   -g [ --sigma ] arg (=0)         sigma used for smoothing (no smoothing if 
 *                                   zero)
 *   -o [ --csv ] arg                specify the output directory (default is 
 *                                   ./output)
 *   -v [ --vis ] arg                visualize contours
 *   -x [ --prefix ] arg             output file prefix
 *   -w [ --wordy ]                  verbose/wordy/debug
 * \endcode
 * \author David Stutz
 */
int main(int argc, const char** argv) {

    boost::program_options::options_description desc("Allowed options");
    desc.add_options()
        ("help,h", "produce help message")
        ("input,i", boost::program_options::value&lt;std::string&gt;(), "the folder to process (can also be passed as positional argument)")
        ("superpixels,s", boost::program_options::value&lt;int&gt;()-&gt;default_value(400), "number of superpixles")
        ("sigma,g", boost::program_options::value&lt;float&gt;()-&gt;default_value(0.0f), "sigma used for smoothing (no smoothing if zero)")
        ("csv,o", boost::program_options::value&lt;std::string&gt;()-&gt;default_value(""), "specify the output directory (default is ./output)")
        ("vis,v", boost::program_options::value&lt;std::string&gt;()-&gt;default_value(""), "visualize contours")
        ("prefix,x", boost::program_options::value&lt;std::string&gt;()-&gt;default_value(""), "output file prefix")
        ("wordy,w", "verbose/wordy/debug");

    boost::program_options::positional_options_description positionals;
    positionals.add("input", 1);

    boost::program_options::variables_map parameters;
    boost::program_options::store(boost::program_options::command_line_parser(argc, argv).options(desc).positional(positionals).run(), parameters);
    boost::program_options::notify(parameters);

    if (parameters.find("help") != parameters.end()) {
        std::cout &lt;&lt; desc &lt;&lt; std::endl;
        return 1;
    }

    boost::filesystem::path output_dir(parameters["csv"].as&lt;std::string&gt;());
    if (!output_dir.empty()) {
        if (!boost::filesystem::is_directory(output_dir)) {
            boost::filesystem::create_directories(output_dir);
        }
    }

    boost::filesystem::path vis_dir(parameters["vis"].as&lt;std::string&gt;());
    if (!vis_dir.empty()) {
        if (!boost::filesystem::is_directory(vis_dir)) {
            boost::filesystem::create_directories(vis_dir);
        }
    }

    boost::filesystem::path input_dir(parameters["input"].as&lt;std::string&gt;());
    if (!boost::filesystem::is_directory(input_dir)) {
        std::cout &lt;&lt; "Image directory not found ..." &lt;&lt; std::endl;
        return 1;
    }

    std::string prefix = parameters["prefix"].as&lt;std::string&gt;();

    bool wordy = false;
    if (parameters.find("wordy") != parameters.end()) {
        wordy = true;
    }

    int superpixels = parameters["superpixels"].as&lt;int&gt;();

    std::multimap&lt;std::string, boost::filesystem::path&gt; images;
    std::vector&lt;std::string&gt; extensions;
    IOUtil::getImageExtensions(extensions);
    IOUtil::readDirectory(input_dir, extensions, images);

    float total = 0;
    for (std::multimap&lt;std::string, boost::filesystem::path&gt;::iterator it = images.begin(); 
            it != images.end(); ++it) {

        cv::Mat image = cv::imread(it-&gt;first);

        float sigma = parameters["sigma"].as&lt;float&gt;();
        if (sigma &gt; 0.01) {
            int size = std::ceil(sigma*4) + 1;
            cv::GaussianBlur(image, image, cv::Size (size, size), sigma, sigma);
        }

        int region_size = SuperpixelTools::computeRegionSizeFromSuperpixels(image, 
                superpixels);
        cv::Mat markers(image.rows, image.cols, CV_32SC1, cv::Scalar(0));

        int label = 1;
        for (int i = region_size/2; i &lt; image.rows; i += region_size) {
            for (int j = region_size/2; j &lt; image.cols; j += region_size) {
                markers.at&lt;int&gt;(i, j) = label;
                label++;
            }
        }

        cv::Mat labels;

        boost::timer timer;
        cv::watershed(image, markers);
        SuperpixelTools::assignBoundariesToSuperpixels(image, markers, labels);    
        float elapsed = timer.elapsed();
        total += elapsed;

        int unconnected_components = SuperpixelTools::relabelConnectedSuperpixels(labels);

        if (wordy) {
            std::cout &lt;&lt; SuperpixelTools::countSuperpixels(labels) &lt;&lt; " superpixels for " &lt;&lt; it-&gt;first 
                    &lt;&lt; " (" &lt;&lt; unconnected_components &lt;&lt; " not connected; " 
                    &lt;&lt; elapsed &lt;&lt;")." &lt;&lt; std::endl;
        }

        if (!output_dir.empty()) {
            boost::filesystem::path csv_file(output_dir 
                    / boost::filesystem::path(prefix + it-&gt;second.stem().string() + ".csv"));
            IOUtil::writeMatCSV&lt;int&gt;(csv_file, labels);
        }

        if (!vis_dir.empty()) {
            boost::filesystem::path contours_file(vis_dir 
                    / boost::filesystem::path(prefix + it-&gt;second.stem().string() + ".png"));
            cv::Mat image_contours;
            Visualization::drawContours(image, labels, image_contours);
            cv::imwrite(contours_file.string(), image_contours);
        }
    }

    if (wordy) {
        std::cout &lt;&lt; "Average time: " &lt;&lt; total / images.size() &lt;&lt; "." &lt;&lt; std::endl;
    }

    if (!output_dir.empty()) {
        std::ofstream runtime_file(output_dir.string() + "/" + prefix + "runtime.txt", 
                std::ofstream::out | std::ofstream::app);

        runtime_file &lt;&lt; total / images.size() &lt;&lt; "\n";
        runtime_file.close();
    }

    return 0;
}
</pre><p>The corresponding CMake file might look like this: </p><pre class="fragment">find_package(OpenCV REQUIRED)
find_package(Boost COMPONENTS system filesystem program_options REQUIRED)

include_directories(../lib_eval/
    ${OpenCV_INCLUDE_DIRS} 
    ${Boost_INCLUDE_DIRS}
)
add_executable(w_cli main.cpp)
target_link_libraries(w_cli
    eval
    ${Boost_LIBRARIES}
    ${OpenCV_LIBS}
)
</pre><p>The CMake file can be found in <code>w_cli</code>; then <code>CMakeLists.txt</code> in the root of the repository can be adapted to include </p><pre class="fragment">add_subdirectory(w_cli)
</pre><p>after the <code>lib_eval</code> directory was added. After building, the command line tool can be called as follows: </p><pre class="fragment">$ ../bin/example_command_line_tool --help
Allowed options:
  -h [ --help ]                   produce help message
  -i [ --input ] arg              the folder to process (can also be passed as 
                                  positional argument)
  -s [ --superpixels ] arg (=400) number of superpixles
  -g [ --sigma ] arg (=0)         sigma used for smoothing (no smoothing if 
                                  zero)
  -o [ --csv ] arg                specify the output directory (default is 
                                  ./output)
  -v [ --vis ] arg                visualize contours
  -x [ --prefix ] arg             output file prefix
  -w [ --wordy ]                  verbose/wordy/debug
</pre><h2>Parameter Optimization</h2>
<p>The parameter optimization tools as defined in <code><a class="el" href="parameter__optimization__tool_8h.html">lib_eval/parameter_optimization_tool.h</a></code> can be used as in the following command line tool: </p><pre class="fragment">#include &lt;opencv2/opencv.hpp&gt;
#include &lt;boost/filesystem.hpp&gt;
#include &lt;boost/timer.hpp&gt;
#include &lt;boost/program_options.hpp&gt;
#include &lt;glog/logging.h&gt;

#include "io_util.h"
#include "parameter_optimization_tool.h"

/**Example of parameter optimization for an adapted W as used in the
 * example for submitting a new algorithm to the benchmark in docs/EXAMPLE.md.
 * $ ../bin/example_parameter_optimization --help
 * @code {sh}
 * Allowed options:
 *   --img-directory arg   image directory
 *   --gt-directory arg    ground truth directory
 *   --base-directory arg  base directory
 *   --help                produce help message
 * \endcode
 * \author David Stutz
 */
int main(int argc, const char** argv) {

    boost::program_options::options_description desc("Allowed options");
    desc.add_options()
        ("img-directory", boost::program_options::value&lt;std::string&gt;(), "image directory")
        ("gt-directory", boost::program_options::value&lt;std::string&gt;(), "ground truth directory")
        ("base-directory", boost::program_options::value&lt;std::string&gt;(), "base directory")
        ("help", "produce help message");

    boost::program_options::positional_options_description positionals;
    positionals.add("img-directory", 1);
    positionals.add("gt-directory", 1);
    positionals.add("base-directory", 1);

    boost::program_options::variables_map parameters;
    boost::program_options::store(boost::program_options::command_line_parser(argc, argv).options(desc).positional(positionals).run(), parameters);
    boost::program_options::notify(parameters);

    if (parameters.find("help") != parameters.end()) {
        std::cout &lt;&lt; desc &lt;&lt; std::endl;
        return 1;
    }

    boost::filesystem::path img_directory(parameters["img-directory"].as&lt;std::string&gt;());
    if (!boost::filesystem::is_directory(img_directory)) {
        std::cout &lt;&lt; "Image directory does not exist." &lt;&lt; std::endl;
        return 1;
    }

    boost::filesystem::path gt_directory(parameters["gt-directory"].as&lt;std::string&gt;());
    if (!boost::filesystem::is_directory(gt_directory)) {
        std::cout &lt;&lt; "Ground truth directory does not exist." &lt;&lt; std::endl;
        return 1;
    }

    boost::filesystem::path base_directory(parameters["base-directory"].as&lt;std::string&gt;());
    if (!boost::filesystem::is_directory(base_directory)) {
        boost::filesystem::create_directories(base_directory);
    }

    std::vector&lt;int&gt; superpixels = {400, 1200, 3600};

    for (unsigned int k = 0; k &lt; superpixels.size(); k++) {
        ParameterOptimizationTool tool(img_directory, gt_directory,
                base_directory / boost::filesystem::path(std::to_string(superpixels[k])),
                "./bin/example_command_line_tool", "");

        tool.addIntegerParameter("superpixels", "--superpixels", std::vector&lt;int&gt;{superpixels[k]});
        tool.addFloatParameter("sigma", "--sigma", std::vector&lt;float&gt;{0.5f, 1.f, 1.5f});
        tool.optimize();
    }

    return 0;
}
</pre><p>The command line tool can be run using: </p><pre class="fragment">$ ../bin/example_parameter_optimization --help
Allowed options:
  --img-directory arg   image directory
  --gt-directory arg    ground truth directory
  --base-directory arg  base directory
  --help                produce help message
</pre><p>After changing the directory to the repository root (i.e. <code>~/superpixel-benchmark/</code>), parameter optimization can be run. Note that we changed the directory as the path to the command line tool is hard-coded in the listing above. Running parameter optimization looks as follows: </p><pre class="fragment">$ ./bin/example_parameter_optimization data/BSDS500/images/val/ data/BSDS500/csv_groundTruth/val/ experiments/
Added integer parameter --superpixels: 400
Added float parameter --sigma: 0.5,1,1.5
Total: 3 combinations.
Time remaining: 52.9239 (26.4619) ...
Added integer parameter --superpixels: 1200
Added float parameter --sigma: 0.5,1,1.5
Total: 3 combinations.
Time remaining: 43.2005 (21.6003) ...
Added integer parameter --superpixels: 3600
Added float parameter --sigma: 0.5,1,1.5
Total: 3 combinations.
Time remaining: 51.2812 (25.6406) ...
</pre><p>Parameter optimization will create a directory <code>experiments/val/</code> with subdirectories <code>400/</code>, <code>1200/</code> and <code>3600/</code>. Each directory contains a summary of parameter optimization in <code>parameter_optimization.csv</code>. In the above examples, this looks as follows: </p><pre class="fragment">sp_directory,superpixels,sigma,rec_average,ue_np_average,co_average,score,co_score,sp_average
experiments/400/1490992372,400,1,0.767879,0.105258,0.252559,0.83131,0.639688,389.86
experiments/400/1490992398,400,1.5,0.763123,0.103071,0.262798,0.830026,0.642172,390.16
experiments/400/1490992419,400,0.5,0.751224,0.111048,0.245077,0.820088,0.629645,388.14
best,400,1
co_best,400,1.5
</pre><p>Where the parameters corresponding to the row <code>best</code> are supposed to be taken as they jointly optimize Boundary Recall and Undersegmentation. In this case, the best sigma is 1.5 for 400 superpixels; for 1200 and 3600 superpixels the best sigma is 1. So in the following we will go with sigma equals 1.</p>
<h2><a class="el" href="classEvaluation.html" title="Provides measures to evaluate (over-) segmentations. ">Evaluation</a></h2>
<p>Once the parameters are decided, evaluation is done using <code>eval_summary_cli</code> and <code>eval_average_cli</code>. The following bash script does this for numbers of superpixels in [200, 5200]: </p><pre class="fragment">#!/bin/sh
for SUPERPIXEL in "200" "300" "400" "600" "800" "1000" "1200" "1400" "1600" "1800" "2000" "2400" "2800" "3200" "3600" "4000" "4600" "5200"
do
    ./bin/w_cli data/BSDS500/images/test/ --superpixels $SUPERPIXEL -o experiments/test/$SUPERPIXEL -w
    ./bin/eval_summary_cli experiments/test/$SUPERPIXEL data/BSDS500/images/test data/BSDS500/csv_groundTruth/test --append-file experiments/test/w.csv --vis
    find ./output/w/$SUPERPIXEL -type f -name '*[^summary|correlation|results].csv' -delete
done

./bin/eval_average_cli experiments/test/w.csv -o output/w_average.csv
</pre><p>The script will create a directory <code>experiments/test</code> where the final results can be found in <code>w.csv</code> and <code>w_average.csv</code>. Note that evaluation may, overall, take several minutes.</p>
<h2>Submit Implementation</h2>
<p>Checking the list in <a class="el" href="SUBMISSION_8md.html">Submission</a>:</p>
<ul>
<li>We optimized parameters on the validation set of the BSDS500 dataset;</li>
<li>the computed superpixel segmentations are post-processed using <code><a class="el" href="classSuperpixelTools.html#adc11994f0a1575477c7f4cb04ae90284" title="Relabel superpixels based on connected components. ">SuperpixelTools::relabelConnectedSuperpixels</a></code> (after the boundaries computed by W are converted to superpixel labels using <code><a class="el" href="classSuperpixelTools.html#a0816df16890a5ae85051c5aba777bf62" title="Compute region size from desired number of superpixels. ">SuperpixelTools::computeRegionSizeFromSuperpixels</a></code>);</li>
<li>the initial markers are placed on a regular grid according to <code><a class="el" href="classSuperpixelTools.html#a0816df16890a5ae85051c5aba777bf62" title="Compute region size from desired number of superpixels. ">SuperpixelTools::computeRegionSizeFromSuperpixels</a></code>;</li>
<li>and evaluation is performed for numbers of superpixels in [200, 5200].</li>
</ul>
<p>A submission could now exist of all the involved files (as discussed above), including a guide detailing building and evaluation instructions. This could for example be put into a separate repository or a fork of this repository. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 16 2017 16:39:17 for Superpixel Benchmark by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
